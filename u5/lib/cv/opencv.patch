diff --git a/3rdparty/openjpeg/CMakeLists.txt b/3rdparty/openjpeg/CMakeLists.txt
index 4e9e260e96..4a49db9252 100644
--- a/3rdparty/openjpeg/CMakeLists.txt
+++ b/3rdparty/openjpeg/CMakeLists.txt
@@ -142,6 +142,7 @@ CHECK_INCLUDE_FILE("sys/types.h"    HAVE_SYS_TYPES_H)
 CHECK_INCLUDE_FILE("unistd.h"       HAVE_UNISTD_H)
 
 # Allocating Aligned Memory Blocks
+
 include(CheckIncludeFiles)
 check_include_files(malloc.h OPJ_HAVE_MALLOC_H)
 include(CheckSymbolExists)
@@ -150,7 +151,7 @@ check_symbol_exists(_aligned_malloc malloc.h OPJ_HAVE__ALIGNED_MALLOC)
 # posix_memalign (needs _POSIX_C_SOURCE >= 200112L on Linux)
 set(_prev_CMAKE_REQUIRED_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS})
 set(CMAKE_REQUIRED_DEFINITIONS -D_POSIX_C_SOURCE=200112L)
-check_symbol_exists(posix_memalign stdlib.h OPJ_HAVE_POSIX_MEMALIGN)
+#check_symbol_exists(posix_memalign stdlib.h OPJ_HAVE_POSIX_MEMALIGN)
 set(CMAKE_REQUIRED_DEFINITIONS ${_prev_CMAKE_REQUIRED_DEFINITIONS})
 unset(_prev_CMAKE_REQUIRED_DEFINITIONS)
 # memalign (obsolete)
diff --git a/apps/CMakeLists.txt b/apps/CMakeLists.txt
index e9a7be7c66..58513715fb 100644
--- a/apps/CMakeLists.txt
+++ b/apps/CMakeLists.txt
@@ -53,6 +53,7 @@ macro(ocv_add_app directory)
   endif()
 endmacro()
 
+if (NOT DEFINED ZEPHYR_CUSTOM_BUILD)
 #ocv_add_app(traincascade)
 #ocv_add_app(createsamples)
 ocv_add_app(annotation)
@@ -60,3 +61,4 @@ ocv_add_app(visualisation)
 ocv_add_app(interactive-calibration)
 ocv_add_app(version)
 ocv_add_app(model-diagnostics)
+endif()
diff --git a/modules/calib3d/src/usac/estimator.cpp b/modules/calib3d/src/usac/estimator.cpp
index 262d9196a2..cae7b43998 100644
--- a/modules/calib3d/src/usac/estimator.cpp
+++ b/modules/calib3d/src/usac/estimator.cpp
@@ -5,6 +5,11 @@
 #include "../precomp.hpp"
 #include "../usac.hpp"
 
+#if defined(__ZEPHYR__)
+#define M_PI 3.14159265358979323846
+#define M_SQRT2 1.41421356237309504880
+#endif
+
 namespace cv { namespace usac {
 class HomographyEstimatorImpl : public HomographyEstimator {
 private:
diff --git a/modules/calib3d/src/usac/utils.cpp b/modules/calib3d/src/usac/utils.cpp
index 8d95fb9c33..85787515c0 100644
--- a/modules/calib3d/src/usac/utils.cpp
+++ b/modules/calib3d/src/usac/utils.cpp
@@ -7,6 +7,11 @@
 #include "opencv2/flann/miniflann.hpp"
 #include <map>
 
+#if defined(__ZEPHYR__)
+#define M_PI 3.14159265358979323846
+#define M_SQRT2 1.41421356237309504880
+#endif
+
 namespace cv { namespace usac {
 /*
 SolvePoly is used to find only real roots of N-degree polynomial using Sturm sequence.
diff --git a/modules/core/src/parallel.cpp b/modules/core/src/parallel.cpp
index 09c86e94d2..7285dc6803 100644
--- a/modules/core/src/parallel.cpp
+++ b/modules/core/src/parallel.cpp
@@ -521,6 +521,7 @@ void parallel_for_(const cv::Range& range, const cv::ParallelLoopBody& body, dou
     bool isNotNestedRegion = !flagNestedParallelFor.load();
     if (isNotNestedRegion)
       isNotNestedRegion = !flagNestedParallelFor.exchange(true);
+#if !defined(__ZEPHYR__)
     if (isNotNestedRegion)
     {
         try
@@ -535,6 +536,7 @@ void parallel_for_(const cv::Range& range, const cv::ParallelLoopBody& body, dou
         }
     }
     else // nested parallel_for_() calls are not parallelized
+#endif  /* __ZEPHYR__ */
     {
         CV_UNUSED(nstripes);
         body(range);
diff --git a/modules/flann/include/opencv2/flann/allocator.h b/modules/flann/include/opencv2/flann/allocator.h
index d5870a0181..8d2514682f 100644
--- a/modules/flann/include/opencv2/flann/allocator.h
+++ b/modules/flann/include/opencv2/flann/allocator.h
@@ -71,7 +71,7 @@ T* allocate(size_t count = 1)
  */
 
 const size_t     WORDSIZE=16;
-const  size_t     BLOCKSIZE=8192;
+const  size_t     ALLOC_BLOCKSIZE=8192;
 
 class PooledAllocator
 {
@@ -94,7 +94,7 @@ public:
     /**
         Default constructor. Initializes a new pool.
      */
-    PooledAllocator(int blockSize = BLOCKSIZE)
+    PooledAllocator(int blockSize = ALLOC_BLOCKSIZE)
     {
         blocksize = blockSize;
         remaining = 0;
@@ -141,8 +141,8 @@ public:
             wastedMemory += remaining;
 
             /* Allocate new storage. */
-            blockSize = (size + sizeof(void*) + (WORDSIZE-1) > BLOCKSIZE) ?
-                        size + sizeof(void*) + (WORDSIZE-1) : BLOCKSIZE;
+            blockSize = (size + sizeof(void*) + (WORDSIZE-1) > ALLOC_BLOCKSIZE) ?
+                        size + sizeof(void*) + (WORDSIZE-1) : ALLOC_BLOCKSIZE;
 
             // use the standard C malloc to allocate memory
             void* m = ::malloc(blockSize);
diff --git a/modules/imgproc/src/shapedescr.cpp b/modules/imgproc/src/shapedescr.cpp
index f2de38168a..98b947698c 100644
--- a/modules/imgproc/src/shapedescr.cpp
+++ b/modules/imgproc/src/shapedescr.cpp
@@ -43,6 +43,11 @@
 
 namespace cv
 {
+#if defined(__ZEPHYR__)
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
+#endif
 
 const float EPS = 1.0e-4f;
 
diff --git a/modules/objdetect/src/cascadedetect.cpp b/modules/objdetect/src/cascadedetect.cpp
index 97b9d70fef..9ceec68b43 100644
--- a/modules/objdetect/src/cascadedetect.cpp
+++ b/modules/objdetect/src/cascadedetect.cpp
@@ -1062,22 +1062,30 @@ public:
                             result = -(int)classifier->data.stages.size();
                         if( classifier->data.stages.size() + result == 0 )
                         {
+#if !defined(__ZEPHYR__)
                             mtx->lock();
+#endif
                             rectangles->push_back(Rect(cvRound(x*scalingFactor),
                                                        cvRound(y*scalingFactor),
                                                        winSize.width, winSize.height));
                             rejectLevels->push_back(-result);
                             levelWeights->push_back(gypWeight);
+#if !defined(__ZEPHYR__)
                             mtx->unlock();
+#endif
                         }
                     }
                     else if( result > 0 )
                     {
+#if !defined(__ZEPHYR__)
                         mtx->lock();
+#endif
                         rectangles->push_back(Rect(cvRound(x*scalingFactor),
                                                    cvRound(y*scalingFactor),
                                                    winSize.width, winSize.height));
+#if !defined(__ZEPHYR__)
                         mtx->unlock();
+#endif
                     }
                     if( result == 0 )
                         x += yStep;
diff --git a/modules/objdetect/src/detection_based_tracker.cpp b/modules/objdetect/src/detection_based_tracker.cpp
index 29504a43fc..92b2893968 100644
--- a/modules/objdetect/src/detection_based_tracker.cpp
+++ b/modules/objdetect/src/detection_based_tracker.cpp
@@ -45,9 +45,11 @@
 
 #include "opencv2/core/utility.hpp"
 
+#if !defined(__ZEPHYR__)
 #include <thread>
 #include <mutex>
 #include <condition_variable>
+#endif
 
 #if defined(DEBUG) || defined(_DEBUG)
 #undef DEBUGLOGS
@@ -128,26 +130,34 @@ class cv::DetectionBasedTracker::SeparateDetectionWork
         }
         void setParameters(const cv::DetectionBasedTracker::Parameters& params)
         {
+#if !defined(__ZEPHYR__)
             std::unique_lock<std::mutex> mtx_lock(mtx);
+#endif
             parameters = params;
         }
 
         inline void init()
         {
+#if !defined(__ZEPHYR__)
             std::unique_lock<std::mutex> mtx_lock(mtx);
+#endif
             stateThread = STATE_THREAD_STOPPED;
             isObjectDetectingReady = false;
             shouldObjectDetectingResultsBeForgot = false;
+#if !defined(__ZEPHYR__)
             objectDetectorThreadStartStop.notify_one();
+#endif
         }
     protected:
 
         DetectionBasedTracker& detectionBasedTracker;
         cv::Ptr<DetectionBasedTracker::IDetector> cascadeInThread;
+#if !defined(__ZEPHYR__)
         std::thread second_workthread;
         std::mutex mtx;
         std::condition_variable objectDetectorRun;
         std::condition_variable objectDetectorThreadStartStop;
+#endif
         std::vector<cv::Rect> resultDetect;
         volatile bool isObjectDetectingReady;
         volatile bool shouldObjectDetectingResultsBeForgot;
@@ -190,20 +200,26 @@ cv::DetectionBasedTracker::SeparateDetectionWork::~SeparateDetectionWork()
     if(stateThread!=STATE_THREAD_STOPPED) {
         LOGE("\n\n\nATTENTION!!! dangerous algorithm error: destructor DetectionBasedTracker::DetectionBasedTracker::~SeparateDetectionWork is called before stopping the workthread");
     }
+#if !defined(__ZEPHYR__)
     second_workthread.join();
+#endif
 }
 bool cv::DetectionBasedTracker::SeparateDetectionWork::run()
 {
     LOGD("DetectionBasedTracker::SeparateDetectionWork::run() --- start");
+#if !defined(__ZEPHYR__)
     std::unique_lock<std::mutex> mtx_lock(mtx);
+#endif
     // unlocked when leaving scope
     if (stateThread != STATE_THREAD_STOPPED) {
         LOGE("DetectionBasedTracker::SeparateDetectionWork::run is called while the previous run is not stopped");
         return false;
     }
     stateThread=STATE_THREAD_WORKING_SLEEPING;
+#if !defined(__ZEPHYR__)
     second_workthread = std::thread(workcycleObjectDetectorFunction, (void*)this); //TODO: add attributes?
     objectDetectorThreadStartStop.wait(mtx_lock);
+#endif
     LOGD("DetectionBasedTracker::SeparateDetectionWork::run --- end");
     return true;
 }
@@ -238,19 +254,26 @@ void cv::DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector()
     std::vector<Rect> objects;
 
     CV_Assert(stateThread==STATE_THREAD_WORKING_SLEEPING);
+#if !defined(__ZEPHYR__)
     std::unique_lock<std::mutex> mtx_lock(mtx);
+#endif
     {
+#if !defined(__ZEPHYR__)
         objectDetectorThreadStartStop.notify_one();
+#endif
         LOGD("DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- before waiting");
         CV_Assert(stateThread==STATE_THREAD_WORKING_SLEEPING);
+#if !defined(__ZEPHYR__)
         objectDetectorRun.wait(mtx_lock);
+#endif
         if (isWorking()) {
             stateThread=STATE_THREAD_WORKING_WITH_IMAGE;
         }
         LOGD("DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- after waiting");
     }
+#if !defined(__ZEPHYR__)
     mtx_lock.unlock();
-
+#endif
     bool isFirstStep=true;
 
     isObjectDetectingReady=false;
@@ -262,19 +285,26 @@ void cv::DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector()
         if (! isFirstStep) {
             LOGD("DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- before waiting");
             CV_Assert(stateThread==STATE_THREAD_WORKING_SLEEPING);
+#if !defined(__ZEPHYR__)
             mtx_lock.lock();
+#endif
             if (!isWorking()) {//it is a rare case, but may cause a crash
                 LOGD("DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- go out from the workcycle from inner part of lock just before waiting");
+#if !defined(__ZEPHYR__)
                 mtx_lock.unlock();
+#endif
                 break;
             }
             CV_Assert(stateThread==STATE_THREAD_WORKING_SLEEPING);
+#if !defined(__ZEPHYR__)
             objectDetectorRun.wait(mtx_lock);
+#endif
             if (isWorking()) {
                 stateThread=STATE_THREAD_WORKING_WITH_IMAGE;
             }
+#if !defined(__ZEPHYR__)
             mtx_lock.unlock();
-
+#endif
             LOGD("DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- after waiting");
         } else {
             isFirstStep=false;
@@ -320,7 +350,9 @@ void cv::DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector()
         (void)(dt_detect_ms);
 
         LOGI("DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector() --- objects num==%d, t_ms=%.4f", (int)objects.size(), dt_detect_ms);
+#if !defined(__ZEPHYR__)
         mtx_lock.lock();
+#endif
         if (!shouldObjectDetectingResultsBeForgot) {
             resultDetect=objects;
             isObjectDetectingReady=true;
@@ -332,8 +364,9 @@ void cv::DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector()
         if(isWorking()) {
             stateThread=STATE_THREAD_WORKING_SLEEPING;
         }
+#if !defined(__ZEPHYR__)
         mtx_lock.unlock();
-
+#endif
         objects.clear();
     }// while(isWorking())
 
@@ -343,26 +376,35 @@ void cv::DetectionBasedTracker::SeparateDetectionWork::workcycleObjectDetector()
 void cv::DetectionBasedTracker::SeparateDetectionWork::stop()
 {
     //FIXME: TODO: should add quickStop functionality
-  std::unique_lock<std::mutex> mtx_lock(mtx);
+#if !defined(__ZEPHYR__)
+    std::unique_lock<std::mutex> mtx_lock(mtx);
+#endif
     if (!isWorking()) {
+#if !defined(__ZEPHYR__)
         mtx_lock.unlock();
+#endif
         LOGE("SimpleHighguiDemoCore::stop is called but the SimpleHighguiDemoCore pthread is not active");
         stateThread = STATE_THREAD_STOPPING;
         return;
     }
     stateThread=STATE_THREAD_STOPPING;
     LOGD("DetectionBasedTracker::SeparateDetectionWork::stop: before going to sleep to wait for the signal from the workthread");
+#if !defined(__ZEPHYR__)
     objectDetectorRun.notify_one();
     objectDetectorThreadStartStop.wait(mtx_lock);
+#endif
     LOGD("DetectionBasedTracker::SeparateDetectionWork::stop: after receiving the signal from the workthread, stateThread=%d", (int)stateThread);
+#if !defined(__ZEPHYR__)
     mtx_lock.unlock();
+#endif
 }
 
 void cv::DetectionBasedTracker::SeparateDetectionWork::resetTracking()
 {
     LOGD("DetectionBasedTracker::SeparateDetectionWork::resetTracking");
+#if !defined(__ZEPHYR__)
     std::unique_lock<std::mutex> mtx_lock(mtx);
-
+#endif
     if (stateThread == STATE_THREAD_WORKING_WITH_IMAGE) {
         LOGD("DetectionBasedTracker::SeparateDetectionWork::resetTracking: since workthread is detecting objects at the moment, we should make cascadeInThread stop detecting and forget the detecting results");
         shouldObjectDetectingResultsBeForgot=true;
@@ -374,7 +416,9 @@ void cv::DetectionBasedTracker::SeparateDetectionWork::resetTracking()
     resultDetect.clear();
     isObjectDetectingReady=false;
 
+#if !defined(__ZEPHYR__)
     mtx_lock.unlock();
+#endif
 }
 
 bool cv::DetectionBasedTracker::SeparateDetectionWork::communicateWithDetectingThread(const Mat& imageGray, std::vector<Rect>& rectsWhereRegions)
@@ -390,8 +434,9 @@ bool cv::DetectionBasedTracker::SeparateDetectionWork::communicateWithDetectingT
 
     bool shouldHandleResult = false;
 
+#if !defined(__ZEPHYR__)
     std::unique_lock<std::mutex> mtx_lock(mtx);
-
+#endif
     if (isObjectDetectingReady) {
         shouldHandleResult=true;
         rectsWhereRegions = resultDetect;
@@ -418,11 +463,14 @@ bool cv::DetectionBasedTracker::SeparateDetectionWork::communicateWithDetectingT
 
 
         timeWhenDetectingThreadStartedWork = getTickCount() ;
-
+#if !defined(__ZEPHYR__)
         objectDetectorRun.notify_one();
+#endif
     }
 
+#if !defined(__ZEPHYR__)
     mtx_lock.unlock();
+#endif
     LOGD("DetectionBasedTracker::SeparateDetectionWork::communicateWithDetectingThread: result: shouldHandleResult=%d", (shouldHandleResult?1:0));
 
     return shouldHandleResult;
