diff --git a/drivers/video/ov2640.c b/drivers/video/ov2640.c
index 08527db125c..33e0530e6fe 100644
--- a/drivers/video/ov2640.c
+++ b/drivers/video/ov2640.c
@@ -158,11 +158,113 @@ LOG_MODULE_REGISTER(video_ov2640, CONFIG_VIDEO_LOG_LEVEL);
 #define UXGA_HSIZE     (1600)
 #define UXGA_VSIZE     (1200)
 
+#define VAL_SET(x, mask, rshift, lshift)  \
+		((((x) >> rshift) & mask) << lshift)
+
+#define   CTRLI_V_DIV_SET(x)    VAL_SET(x, 0x3, 0, 3)
+#define   CTRLI_H_DIV_SET(x)    VAL_SET(x, 0x3, 0, 0)
+#define   ZMOW_OUTW_SET(x)      VAL_SET(x, 0xFF, 2, 0)
+#define   ZMOH_OUTH_SET(x)      VAL_SET(x, 0xFF, 2, 0)
+
+#define   ZMHH_ZSPEED_SET(x)    VAL_SET(x, 0x0F, 0, 4)
+#define   ZMHH_OUTH_SET(x)      VAL_SET(x, 0x1, (8+2), 2)
+#define   ZMHH_OUTW_SET(x)      VAL_SET(x, 0x3, (8+2), 0)
+
+#define CIF_WIDTH				352
+#define CIF_HEIGHT				288
+#define HD_720_WIDTH			1280
+#define HD_720_HEIGHT			720
+#define HD_1080_WIDTH			1920
+#define HD_1080_HEIGHT			1080
+#define QCIF_WIDTH				176
+#define QCIF_HEIGHT				144
+#define QQCIF_WIDTH				88
+#define QQCIF_HEIGHT			72
+#define QQVGA_WIDTH				160
+#define QQVGA_HEIGHT			120
+#define QVGA_WIDTH				320
+#define QVGA_HEIGHT				240
+#define SVGA_WIDTH				800
+#define SVGA_HEIGHT				600
+#define SXGA_WIDTH				1280
+#define SXGA_HEIGHT				1024
+#define VGA_WIDTH				640
+#define VGA_HEIGHT				480
+#define UXGA_WIDTH				1600
+#define UXGA_HEIGHT				1200
+#define XGA_WIDTH				1024
+#define XGA_HEIGHT				768
+
 struct ov2640_reg {
 	uint8_t addr;
 	uint8_t value;
 };
 
+struct ov2640_win_size {
+	char				*name;
+	uint32_t				width;
+	uint32_t				height;
+	const struct ov2640_reg	*regs;
+	uint32_t regs_size;
+};
+
+#define PER_SIZE_REG_SEQ(x, y, v_div, h_div, pclk_div)	\
+{ CTRLI, CTRLI_LP_DP | CTRLI_V_DIV_SET(v_div) |	\
+		CTRLI_H_DIV_SET(h_div)},		\
+{ ZMOW, ZMOW_OUTW_SET(x) },			\
+{ ZMOH, ZMOH_OUTH_SET(y) },			\
+{ ZMHH, ZMHH_OUTW_SET(x) | ZMHH_OUTH_SET(y) },	\
+{ R_DVP_SP, pclk_div },				\
+{ RESET, 0x00}
+
+static const struct ov2640_reg ov2640_qqvga_regs[] = {
+	PER_SIZE_REG_SEQ(QQVGA_WIDTH, QQVGA_HEIGHT, 3, 3, 8),
+};
+static const struct ov2640_reg ov2640_qcif_regs[] = {
+	PER_SIZE_REG_SEQ(QCIF_WIDTH, QCIF_HEIGHT, 3, 3, 4),
+};
+static const struct ov2640_reg ov2640_qvga_regs[] = {
+	PER_SIZE_REG_SEQ(QVGA_WIDTH, QVGA_HEIGHT, 2, 2, 4),
+};
+static const struct ov2640_reg ov2640_cif_regs[] = {
+	PER_SIZE_REG_SEQ(CIF_WIDTH, CIF_HEIGHT, 2, 2, 8),
+};
+static const struct ov2640_reg ov2640_vga_regs[] = {
+	PER_SIZE_REG_SEQ(VGA_WIDTH, VGA_HEIGHT, 0, 0, 2),
+};
+static const struct ov2640_reg ov2640_svga_regs[] = {
+	PER_SIZE_REG_SEQ(SVGA_WIDTH, SVGA_HEIGHT, 1, 1, 2),
+};
+static const struct ov2640_reg ov2640_xga_regs[] = {
+	PER_SIZE_REG_SEQ(XGA_WIDTH, XGA_HEIGHT, 0, 0, 2),
+	{ CTRLI,    0x00},
+};
+static const struct ov2640_reg ov2640_sxga_regs[] = {
+	PER_SIZE_REG_SEQ(SXGA_WIDTH, SXGA_HEIGHT, 0, 0, 2),
+	{ CTRLI,    0x00},
+	{ R_DVP_SP, 2 | R_DVP_SP_AUTO_MODE },
+};
+static const struct ov2640_reg ov2640_uxga_regs[] = {
+	PER_SIZE_REG_SEQ(UXGA_WIDTH, UXGA_HEIGHT, 0, 0, 0),
+	{ CTRLI,    0x00},
+	{ R_DVP_SP, 0 | R_DVP_SP_AUTO_MODE },
+};
+
+#define OV2640_SIZE(n, w, h, r) \
+	{.name = n, .width = w , .height = h, .regs = r, .regs_size = ARRAY_SIZE(r) }
+
+static const struct ov2640_win_size ov2640_supported_win_sizes[] = {
+	OV2640_SIZE("QQVGA", QQVGA_WIDTH, QQVGA_HEIGHT, ov2640_qqvga_regs),
+	OV2640_SIZE("QCIF", QCIF_WIDTH, QCIF_HEIGHT, ov2640_qcif_regs),
+	OV2640_SIZE("QVGA", QVGA_WIDTH, QVGA_HEIGHT, ov2640_qvga_regs),
+	OV2640_SIZE("CIF", CIF_WIDTH, CIF_HEIGHT, ov2640_cif_regs),
+	OV2640_SIZE("VGA", VGA_WIDTH, VGA_HEIGHT, ov2640_vga_regs),
+	OV2640_SIZE("SVGA", SVGA_WIDTH, SVGA_HEIGHT, ov2640_svga_regs),
+	OV2640_SIZE("XGA", XGA_WIDTH, XGA_HEIGHT, ov2640_xga_regs),
+	OV2640_SIZE("SXGA", SXGA_WIDTH, SXGA_HEIGHT, ov2640_sxga_regs),
+	OV2640_SIZE("UXGA", UXGA_WIDTH, UXGA_HEIGHT, ov2640_uxga_regs),
+};
+
 static const struct ov2640_reg default_regs[] = {
 	{ BANK_SEL, BANK_SEL_DSP },
 	{ 0x2c,     0xff },
@@ -400,7 +502,7 @@ static const struct ov2640_reg uxga_regs[] = {
 	{ R_DVP_SP, R_DVP_SP_AUTO_MODE | 0x04},
 
 	{ R_BYPASS, R_BYPASS_DSP_EN },
-	{ RESET,    0x00 },
+//	{ RESET,    0x00 },
 	{0, 0},
 };
 
@@ -472,27 +574,27 @@ struct ov2640_data {
 	}
 
 static const struct video_format_cap fmts[] = {
-	OV2640_VIDEO_FORMAT_CAP(160, 120, VIDEO_PIX_FMT_RGB565),   /* QQVGA */
-	OV2640_VIDEO_FORMAT_CAP(176, 144, VIDEO_PIX_FMT_RGB565),   /* QCIF  */
+	OV2640_VIDEO_FORMAT_CAP(QQVGA_WIDTH, QQVGA_HEIGHT, VIDEO_PIX_FMT_RGB565),   /* QQVGA */
+	OV2640_VIDEO_FORMAT_CAP(QCIF_WIDTH, QCIF_HEIGHT, VIDEO_PIX_FMT_RGB565),   /* QCIF  */
 	OV2640_VIDEO_FORMAT_CAP(240, 160, VIDEO_PIX_FMT_RGB565),   /* HQVGA */
 	OV2640_VIDEO_FORMAT_CAP(240, 240, VIDEO_PIX_FMT_RGB565),   /* 240x240 */
 	OV2640_VIDEO_FORMAT_CAP(320, 240, VIDEO_PIX_FMT_RGB565),   /* QVGA  */
-	OV2640_VIDEO_FORMAT_CAP(352, 288, VIDEO_PIX_FMT_RGB565),   /* CIF   */
-	OV2640_VIDEO_FORMAT_CAP(640, 480, VIDEO_PIX_FMT_RGB565),   /* VGA   */
-	OV2640_VIDEO_FORMAT_CAP(800, 600, VIDEO_PIX_FMT_RGB565),   /* SVGA  */
-	OV2640_VIDEO_FORMAT_CAP(1024, 768, VIDEO_PIX_FMT_RGB565),  /* XVGA  */
-	OV2640_VIDEO_FORMAT_CAP(1280, 1024, VIDEO_PIX_FMT_RGB565), /* SXGA  */
-	OV2640_VIDEO_FORMAT_CAP(1600, 1200, VIDEO_PIX_FMT_RGB565), /* UXGA  */
-	OV2640_VIDEO_FORMAT_CAP(160, 120, VIDEO_PIX_FMT_JPEG),     /* QQVGA */
-	OV2640_VIDEO_FORMAT_CAP(176, 144, VIDEO_PIX_FMT_JPEG),     /* QCIF  */
+	OV2640_VIDEO_FORMAT_CAP(CIF_WIDTH, CIF_HEIGHT, VIDEO_PIX_FMT_RGB565),   /* CIF   */
+	OV2640_VIDEO_FORMAT_CAP(VGA_WIDTH, VGA_HEIGHT, VIDEO_PIX_FMT_RGB565),   /* VGA   */
+	OV2640_VIDEO_FORMAT_CAP(SVGA_WIDTH, SVGA_HEIGHT, VIDEO_PIX_FMT_RGB565),   /* SVGA  */
+	OV2640_VIDEO_FORMAT_CAP(XGA_WIDTH, XGA_HEIGHT, VIDEO_PIX_FMT_RGB565),  /* XVGA  */
+	OV2640_VIDEO_FORMAT_CAP(SXGA_WIDTH, SXGA_HEIGHT, VIDEO_PIX_FMT_RGB565), /* SXGA  */
+	OV2640_VIDEO_FORMAT_CAP(UXGA_WIDTH, UXGA_HEIGHT, VIDEO_PIX_FMT_RGB565), /* UXGA  */
+	OV2640_VIDEO_FORMAT_CAP(QQVGA_WIDTH, QQVGA_HEIGHT, VIDEO_PIX_FMT_JPEG),     /* QQVGA */
+	OV2640_VIDEO_FORMAT_CAP(QCIF_WIDTH, QCIF_HEIGHT, VIDEO_PIX_FMT_JPEG),     /* QCIF  */
 	OV2640_VIDEO_FORMAT_CAP(240, 160, VIDEO_PIX_FMT_JPEG),     /* HQVGA */
 	OV2640_VIDEO_FORMAT_CAP(320, 240, VIDEO_PIX_FMT_JPEG),     /* QVGA  */
-	OV2640_VIDEO_FORMAT_CAP(352, 288, VIDEO_PIX_FMT_JPEG),     /* CIF   */
-	OV2640_VIDEO_FORMAT_CAP(640, 480, VIDEO_PIX_FMT_JPEG),     /* VGA   */
-	OV2640_VIDEO_FORMAT_CAP(800, 600, VIDEO_PIX_FMT_JPEG),     /* SVGA  */
-	OV2640_VIDEO_FORMAT_CAP(1024, 768, VIDEO_PIX_FMT_JPEG),    /* XVGA  */
-	OV2640_VIDEO_FORMAT_CAP(1280, 1024, VIDEO_PIX_FMT_JPEG),   /* SXGA  */
-	OV2640_VIDEO_FORMAT_CAP(1600, 1200, VIDEO_PIX_FMT_JPEG),   /* UXGA  */
+	OV2640_VIDEO_FORMAT_CAP(CIF_WIDTH, CIF_HEIGHT, VIDEO_PIX_FMT_JPEG),     /* CIF   */
+	OV2640_VIDEO_FORMAT_CAP(VGA_WIDTH, VGA_HEIGHT, VIDEO_PIX_FMT_JPEG),     /* VGA   */
+	OV2640_VIDEO_FORMAT_CAP(SVGA_WIDTH, SVGA_HEIGHT, VIDEO_PIX_FMT_JPEG),     /* SVGA  */
+	OV2640_VIDEO_FORMAT_CAP(XGA_WIDTH, XGA_HEIGHT, VIDEO_PIX_FMT_JPEG),    /* XVGA  */
+	OV2640_VIDEO_FORMAT_CAP(SXGA_WIDTH, SXGA_HEIGHT, VIDEO_PIX_FMT_JPEG),   /* SXGA  */
+	OV2640_VIDEO_FORMAT_CAP(UXGA_WIDTH, UXGA_HEIGHT, VIDEO_PIX_FMT_JPEG),   /* UXGA  */
 	{ 0 }
 };
 
@@ -775,6 +877,17 @@ static int ov2640_set_vertical_flip(const struct device *dev, int enable)
 	return ret;
 }
 
+static const struct ov2640_win_size *ov2640_select_win(uint32_t width, uint32_t height)
+{
+	int i, default_size = ARRAY_SIZE(ov2640_supported_win_sizes) - 1;
+	for (i = 0; i < ARRAY_SIZE(ov2640_supported_win_sizes); i++) {
+		if (ov2640_supported_win_sizes[i].width  >= width &&
+		    ov2640_supported_win_sizes[i].height >= height)
+			return &ov2640_supported_win_sizes[i];
+	}
+	return &ov2640_supported_win_sizes[default_size];
+}
+
 static int ov2640_set_resolution(const struct device *dev,
 				uint16_t img_width, uint16_t img_height)
 {
@@ -784,23 +897,23 @@ static int ov2640_set_resolution(const struct device *dev,
 	uint16_t w = img_width;
 	uint16_t h = img_height;
 
+	const struct ov2640_win_size *win = ov2640_select_win(w, h);
+
+	/* Write DSP input registers */
+	ret |= ov2640_write_all(dev, uxga_regs, ARRAY_SIZE(uxga_regs));
+
 	/* Disable DSP */
 	ret |= ov2640_write_reg(&cfg->i2c, BANK_SEL, BANK_SEL_DSP);
 	ret |= ov2640_write_reg(&cfg->i2c, R_BYPASS, R_BYPASS_DSP_BYPAS);
 
-	/* Write output width */
-	ret |= ov2640_write_reg(&cfg->i2c, ZMOW, (w >> 2) & 0xFF); /* OUTW[7:0] (real/4) */
-	ret |= ov2640_write_reg(&cfg->i2c, ZMOH, (h >> 2) & 0xFF); /* OUTH[7:0] (real/4) */
-	ret |= ov2640_write_reg(&cfg->i2c, ZMHH, ((h >> 8) & 0x04) |
-							((w>>10) & 0x03)); /* OUTH[8]/OUTW[9:8] */
+	LOG_INF("Selected resolution %s", win->name);
+
+	ret |= ov2640_write_all(dev, win->regs, win->regs_size);
 
 	/* Set CLKRC */
 	ret |= ov2640_write_reg(&cfg->i2c, BANK_SEL, BANK_SEL_SENSOR);
 	ret |= ov2640_write_reg(&cfg->i2c, CLKRC, cfg->clock_rate_control);
 
-	/* Write DSP input registers */
-	ov2640_write_all(dev, uxga_regs, ARRAY_SIZE(uxga_regs));
-
 	/* Enable DSP */
 	ret |= ov2640_write_reg(&cfg->i2c, BANK_SEL, BANK_SEL_DSP);
 	ret |= ov2640_write_reg(&cfg->i2c, R_BYPASS, R_BYPASS_DSP_EN);
diff --git a/drivers/video/video_stm32_dcmi.c b/drivers/video/video_stm32_dcmi.c
index 363de09717b..11e75e86c7a 100644
--- a/drivers/video/video_stm32_dcmi.c
+++ b/drivers/video/video_stm32_dcmi.c
@@ -81,7 +81,56 @@ void HAL_DCMI_FrameEventCallback(DCMI_HandleTypeDef *hdcmi)
 	k_fifo_put(&dev_data->fifo_out, vbuf);
 
 resume:
+#if defined(CONFIG_SOC_SERIES_STM32U5X)
+	int err = HAL_DCMI_Start_DMA(&dev_data->hdcmi, DCMI_MODE_SNAPSHOT,
+			(uint32_t)dev_data->vbuf->buffer, dev_data->vbuf->bytesused / 4);
+	if (err != HAL_OK) {
+		LOG_ERR("Failed to start DCMI DMA");
+	}
+#else
+	HAL_DCMI_Resume(hdcmi);
+#endif
+}
+
+void HAL_DCMI_VsyncEventCallback(DCMI_HandleTypeDef *hdcmi)
+{
+	struct video_stm32_dcmi_data *dev_data =
+			CONTAINER_OF(hdcmi, struct video_stm32_dcmi_data, hdcmi);
+	struct video_buffer *vbuf;
+
+	if (dev_data->fmt.pixelformat != VIDEO_PIX_FMT_JPEG) {
+		return;
+	}
+
+	HAL_DCMI_Suspend(hdcmi);
+
+	vbuf = k_fifo_get(&dev_data->fifo_in, K_NO_WAIT);
+
+	if (vbuf == NULL) {
+		LOG_DBG("Failed to get buffer from fifo");
+		goto resume;
+	}
+
+	vbuf->bytesused = vbuf->size - __HAL_DMA_GET_COUNTER(dev_data->hdcmi.DMA_Handle);
+
+	vbuf->timestamp = k_uptime_get_32();
+	memcpy(vbuf->buffer, dev_data->vbuf->buffer, vbuf->bytesused);
+
+	k_fifo_put(&dev_data->fifo_out, vbuf);
+
+resume:
+#if defined(CONFIG_SOC_SERIES_STM32U5X)
+	// Stop DMA as in JPEG mode it may be still waiting for more data to come, so we can't restart it directly
+	HAL_DCMI_Stop(&dev_data->hdcmi);
+	int err = HAL_DCMI_Start_DMA(&dev_data->hdcmi, DCMI_MODE_SNAPSHOT,
+			(uint32_t)dev_data->vbuf->buffer, dev_data->vbuf->bytesused / 4);
+	if (err != HAL_OK) {
+		LOG_ERR("Failed to start DCMI DMA");
+	}
+#else
+
 	HAL_DCMI_Resume(hdcmi);
+#endif
 }
 
 static void stm32_dcmi_isr(const struct device *dev)
@@ -109,6 +158,47 @@ void HAL_DMA_ErrorCallback(DMA_HandleTypeDef *hdma)
 	LOG_WRN("%s", __func__);
 }
 
+#if defined(CONFIG_SOC_SERIES_STM32U5X)
+static int stm32_dma_list_init(DMA_HandleTypeDef *hdma)
+{
+	static DMA_NodeTypeDef Node;
+	static DMA_QListTypeDef Queue;
+
+	HAL_StatusTypeDef ret = HAL_OK;
+	/* DMA node configuration declaration */
+	DMA_NodeConfTypeDef pNodeConfig;
+
+	/* Set node configuration ################################################*/
+	pNodeConfig.NodeType 					= DMA_GPDMA_LINEAR_NODE;
+	pNodeConfig.Init.Request 				= GPDMA1_REQUEST_DCMI_PSSI;
+	pNodeConfig.Init.BlkHWRequest 			= DMA_BREQ_SINGLE_BURST;
+	pNodeConfig.Init.Direction 				= DMA_PERIPH_TO_MEMORY;
+	pNodeConfig.Init.SrcInc 				= DMA_SINC_FIXED;
+	pNodeConfig.Init.DestInc 				= DMA_DINC_INCREMENTED;
+	pNodeConfig.Init.SrcDataWidth 			= DMA_SRC_DATAWIDTH_WORD;
+	pNodeConfig.Init.DestDataWidth 			= DMA_DEST_DATAWIDTH_WORD;
+	pNodeConfig.Init.SrcBurstLength 		= 1;
+	pNodeConfig.Init.DestBurstLength 		= 1;
+	pNodeConfig.Init.TransferAllocatedPort = DMA_SRC_ALLOCATED_PORT0|DMA_DEST_ALLOCATED_PORT0;
+	pNodeConfig.Init.TransferEventMode 		= DMA_TCEM_BLOCK_TRANSFER;
+	pNodeConfig.TriggerConfig.TriggerPolarity = DMA_TRIG_POLARITY_MASKED;
+	pNodeConfig.DataHandlingConfig.DataExchange = DMA_EXCHANGE_NONE;
+	pNodeConfig.DataHandlingConfig.DataAlignment = DMA_DATA_RIGHTALIGN_ZEROPADDED;
+	pNodeConfig.SrcAddress 					= 0;
+	pNodeConfig.DstAddress 					= 0;
+	pNodeConfig.DataSize 					= 0;
+
+	/* Build Node1 Node */
+	ret |= HAL_DMAEx_List_BuildNode(&pNodeConfig, &Node);
+	/* Insert Node1 to Queue */
+	ret |= HAL_DMAEx_List_InsertNode_Tail(&Queue, &Node);
+	ret |= HAL_DMAEx_List_SetCircularMode(&Queue);
+	ret |= HAL_DMAEx_List_LinkQ(hdma, &Queue);
+
+	return ret;
+}
+#endif /* !defined(CONFIG_SOC_SERIES_STM32U5X) */
+
 static int stm32_dma_init(const struct device *dev)
 {
 	struct video_stm32_dcmi_data *data = dev->data;
@@ -147,6 +237,30 @@ static int stm32_dma_init(const struct device *dev)
 
 	/*** Configure the DMA ***/
 	/* Set the parameters to be configured */
+
+#if defined(CONFIG_SOC_SERIES_STM32U5X)
+	hdma.Init.Request 		= GPDMA1_REQUEST_DCMI_PSSI;
+	hdma.Init.BlkHWRequest 	= DMA_BREQ_SINGLE_BURST;
+	hdma.Init.Direction 	= DMA_PERIPH_TO_MEMORY;
+	hdma.Init.SrcInc 		= DMA_SINC_FIXED;
+	hdma.Init.DestInc 		= DMA_DINC_INCREMENTED;
+	hdma.Init.SrcDataWidth 	= DMA_SRC_DATAWIDTH_WORD;
+	hdma.Init.DestDataWidth = DMA_DEST_DATAWIDTH_WORD;
+
+	hdma.Init.Priority 		= DMA_LOW_PRIORITY_HIGH_WEIGHT;
+	hdma.Init.SrcBurstLength = 1;
+	hdma.Init.DestBurstLength = 1;
+	hdma.Init.TransferAllocatedPort =
+		DMA_SRC_ALLOCATED_PORT0 | DMA_DEST_ALLOCATED_PORT1;
+	hdma.Init.TransferEventMode = DMA_TCEM_BLOCK_TRANSFER;
+	hdma.Init.Mode 			= DMA_NORMAL;
+
+	hdma.InitLinkedList.Priority 		= DMA_LOW_PRIORITY_LOW_WEIGHT;
+	hdma.InitLinkedList.LinkStepMode 	= DMA_LSM_FULL_EXECUTION;
+	hdma.InitLinkedList.LinkAllocatedPort = DMA_LINK_ALLOCATED_PORT0 | DMA_LINK_ALLOCATED_PORT1;
+	hdma.InitLinkedList.TransferEventMode = DMA_TCEM_LAST_LL_ITEM_TRANSFER;
+	hdma.InitLinkedList.LinkedListMode 	= DMA_LINKEDLIST_CIRCULAR;
+#else /* ! defined(CONFIG_SOC_SERIES_STM32U5X) */
 	hdma.Init.Request		= DMA_REQUEST_DCMI;
 	hdma.Init.Direction		= DMA_PERIPH_TO_MEMORY;
 	hdma.Init.PeriphInc		= DMA_PINC_DISABLE;
@@ -155,6 +269,8 @@ static int stm32_dma_init(const struct device *dev)
 	hdma.Init.MemDataAlignment	= DMA_MDATAALIGN_WORD;
 	hdma.Init.Mode			= DMA_CIRCULAR;
 	hdma.Init.Priority		= DMA_PRIORITY_HIGH;
+#endif /* defined(CONFIG_SOC_SERIES_STM32U5X) */
+
 #if defined(CONFIG_SOC_SERIES_STM32F7X) || defined(CONFIG_SOC_SERIES_STM32H7X)
 	hdma.Init.FIFOMode		= DMA_FIFOMODE_DISABLE;
 #endif
@@ -164,6 +280,9 @@ static int stm32_dma_init(const struct device *dev)
 						config->dma.channel);
 #elif defined(CONFIG_SOC_SERIES_STM32L4X)
 	hdma.Instance = __LL_DMA_GET_CHANNEL_INSTANCE(config->dma.reg, config->dma.channel);
+#elif defined(CONFIG_SOC_SERIES_STM32U5X)
+	hdma.Instance = LL_DMA_GET_CHANNEL_INSTANCE(
+		config->dma.reg, config->dma.channel);
 #endif
 
 	/* Initialize DMA HAL */
@@ -174,6 +293,20 @@ static int stm32_dma_init(const struct device *dev)
 		return -EIO;
 	}
 
+#if defined(CONFIG_SOC_SERIES_STM32U5X)
+	if (HAL_DMAEx_List_Init(&hdma) != HAL_OK) {
+		LOG_ERR("HAL_DMAEx_List_Init Failed");
+		return -EINVAL;
+	}
+	if (stm32_dma_list_init(&hdma) != HAL_OK) {
+		LOG_ERR("stm32_dma_list_init Failed");
+		return -EINVAL;
+	}
+	if (HAL_DMA_ConfigChannelAttributes(&hdma, DMA_CHANNEL_NPRIV) != HAL_OK) {
+		LOG_ERR("HAL_DMA_ConfigChannelAttributes Failed");
+		return -EINVAL;
+	}
+#endif
 	return 0;
 }
 
@@ -270,7 +403,13 @@ static int video_stm32_dcmi_set_stream(const struct device *dev, bool enable,
 	data->hdcmi.Instance->CR &= ~(DCMI_CR_FCRC_0 | DCMI_CR_FCRC_1);
 	data->hdcmi.Instance->CR |= STM32_DCMI_GET_CAPTURE_RATE(data->capture_rate);
 
-	err = HAL_DCMI_Start_DMA(&data->hdcmi, DCMI_MODE_CONTINUOUS,
+	if (data->fmt.pixelformat == VIDEO_PIX_FMT_JPEG) {
+		data->hdcmi.Instance->CR |= DCMI_CR_JPEG;
+	}
+
+	uint32_t dcmi_mode = DCMI_MODE_CONTINUOUS;
+
+	err = HAL_DCMI_Start_DMA(&data->hdcmi, dcmi_mode,
 			(uint32_t)data->vbuf->buffer, data->vbuf->bytesused / 4);
 	if (err != HAL_OK) {
 		LOG_ERR("Failed to start DCMI DMA");
@@ -283,9 +422,13 @@ static int video_stm32_dcmi_set_stream(const struct device *dev, bool enable,
 static int video_stm32_dcmi_enqueue(const struct device *dev, struct video_buffer *vbuf)
 {
 	struct video_stm32_dcmi_data *data = dev->data;
-	const uint32_t buffer_size = data->fmt.pitch * data->fmt.height;
+	uint32_t buffer_size = data->fmt.pitch * data->fmt.height;
+
+	if (data->fmt.pixelformat == VIDEO_PIX_FMT_JPEG) {
+		buffer_size = vbuf->size;
+	}
 
-	if (buffer_size > vbuf->size) {
+	if (0 == buffer_size || buffer_size > vbuf->size) {
 		return -EINVAL;
 	}
 
diff --git a/dts/arm/st/u5/stm32u5.dtsi b/dts/arm/st/u5/stm32u5.dtsi
index 1ea790dd980..b8499dbe37b 100644
--- a/dts/arm/st/u5/stm32u5.dtsi
+++ b/dts/arm/st/u5/stm32u5.dtsi
@@ -887,6 +887,21 @@
 			};
 		};
 
+		#define GPDMA1_REQUEST_DCMI_PSSI     86U
+		#define   DCMI_PSSI_IRQn             119
+
+		dcmi: dcmi@4202C000 {
+			compatible = "st,stm32-dcmi";
+			reg = <0x4202C000 0x400>;
+			interrupts = <DCMI_PSSI_IRQn 0>;
+			interrupt-names = "dcmi";
+			clocks = <&rcc STM32_CLOCK(AHB2, 12U)>;
+
+			dmas = <&gpdma1 5 GPDMA1_REQUEST_DCMI_PSSI (STM32_DMA_PERIPH_TO_MEMORY | STM32_DMA_PERIPH_NO_INC |
+				STM32_DMA_MEM_INC | STM32_DMA_PERIPH_32BITS | STM32_DMA_MEM_32BITS |
+				STM32_DMA_PRIORITY_HIGH) STM32_DMA_FIFO_1_4>;
+			status = "okay";
+		};
 	};
 
 	swj_port: swj_port {
diff --git a/samples/boards/st/uart/circular_dma/boards/nucleo_wba55cg.overlay b/samples/boards/st/uart/circular_dma/boards/nucleo_wba55cg.overlay
index 751836f8554..52382316dd1 100644
--- a/samples/boards/st/uart/circular_dma/boards/nucleo_wba55cg.overlay
+++ b/samples/boards/st/uart/circular_dma/boards/nucleo_wba55cg.overlay
@@ -6,7 +6,7 @@
 
 &usart1 {
 	dmas = <&gpdma1 0 12 (STM32_DMA_PERIPH_TX)
-		&gpdma1 1 11 (STM32_DMA_MODE_CYCLIC | STM32_DMA_PERIPH_RX | STM32_DMA_MEM_8BITS)>;
+			&gpdma1 1 11 (STM32_DMA_MODE_CYCLIC | STM32_DMA_PERIPH_RX | STM32_DMA_MEM_8BITS)>;
 	dma-names = "tx", "rx";
 	fifo-enable;
 };
